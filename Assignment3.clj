; Assignment 3
; Harsh Shah
; 817354961


; 1. Write a function called sdsu-rotate which can rotate a sequence in either direction. The
;    function can return a collection type of your choice. Here are some examples.

(declare helper-rotate-right)
(declare helper-rotate-left)
(defn sdsu-rotate
  [n input-list]
  (if (pos? n)
    (helper-rotate-left (mod n (count input-list))
                        input-list
                        nil)
    (helper-rotate-right (mod (* n -1) (count input-list))
                         nil
                         input-list)))

(defn- helper-rotate-left
  [n start-list end-list]
  (if (zero? n)
    (concat start-list (reverse end-list))
    (helper-rotate-left (dec n)
                        (rest start-list)
                        (conj end-list (first start-list)))))

(defn- helper-rotate-right
  [n start-list end-list]
  (if (zero? n)
    (concat start-list end-list)
    (helper-rotate-right (dec n)
                         (conj start-list (last end-list))
                         (butlast end-list))))

(= (sdsu-rotate 2 [1 2 3 4 5]) '(3 4 5 1 2))
(= (sdsu-rotate -2 [1 2 3 4 5]) '(4 5 1 2 3))
(= (sdsu-rotate 6 [1 2 3 4 5]) '(2 3 4 5 1))
(= (sdsu-rotate 0 [1 2 3]) '(1 2 3))



; 2. If we list all the positive integers below 10 that are multiples of 2 or 5, we get 2, 4, 6, 8, 5.
;    The sum of these multiples is 25. Write a function sdsu-sum that takes three arguments.
;    The first two arguments are the numbers we will take the multiples of. The third argument
;    the number we want the multiples to be less than. Sdsu-sum returns the sum of the
;    multiples of the two numbers less than the third argument.

(declare helper-sum)
(defn sdsu-sum
  [n1 n2 upper-limit]
  (if (or (> n1 upper-limit) (> n2 upper-limit))
    (throw (Exception. "IllegalArgumentException"))
    (if (< n1 n2)
      (helper-sum n1
                  n2
                  upper-limit
                  n1
                  0)
      (helper-sum n1
                  n2
                  upper-limit
                  n2
                  0))))

(defn- helper-sum
  [n1 n2 upper-limit current-n sum]
  (loop [n1 n1
         n2 n2
         upper-limit upper-limit
         current-n current-n
         sum sum]
    (if (= current-n upper-limit)
      sum
      (if (or (= (mod current-n n1) 0) (= (mod current-n n2) 0))
        (recur n1 n2 upper-limit (+ current-n 1) (+ sum current-n))
        (recur n1 n2 upper-limit (+ current-n 1) sum)))))


(= (sdsu-sum 2 5 10) 25)


; 3. A palindromic integer is an integer that reads the same both ways. For example, 101, 121,
;    12321 and 98989 are all palindromic integers. The largest palindromic integer made from
;    the product of two 2-digit numbers is 9009 = 91 * 99. Write a function sdsu-palindome that
;    takes one argument, an integer. The integer indicates the number of digits we are interested
;    in. So (sdsu-palindrome 2) returns the largest palindromic integer made from the product of
;    two 2-digit numbers and (sdsu-palindrome 3) returns the largest palindromic integer
;    made from the product of two 3-digit numbers.

(declare exp)
(declare is-palindrome)
(defn sdsu-palindrome
  [n]
  (when (pos? n)
    (loop [n1 (- (exp n) 1)
           n2 (- (exp n) 1)
           n n]
      (if (is-palindrome (str (* n1 n2)))
        (* n1 n2)
        (if (zero? n2)
          (when-not (zero? n1)
            (recur (dec n1) (dec (exp n)) n))
          (recur n1 (dec n2) n))))))

(defn- exp
  [n]
  (reduce * (repeat n 10)))

(defn is-palindrome
  [n]
  (when (= n (apply str (reverse n)))
    true))


(= (sdsu-palindrome 2) 9009)




; 4. The Fibonacci sequence is generated by adding the previous two terms in the sequence.
;    We will start the sequence with 1 and 2. So the first ten elements are 1, 2, 3, 5, 8, 13, 21,
;    34, 55, 89. Write a function sdsu-fibonacci-even that takes one argument N. The function
;    returns the sum of all the even-valued terms in the Fibonacci sequence that are less then
;    or equal to N.

(defn sdsu-fibonacci-even
  [n]
  {:pre [(pos? n)]}
  (loop [f1 1
         f2 2
         sum 0
         n n]
    (if (> f1 n)
      sum
    (if (even? f1)
      (recur f2 (+ f1 f2) (+ sum f1) n)
      (recur f2 (+ f1 f2) sum n)))))


(= (sdsu-fibonacci-even 20) 10)




; 5. DNA can be represented as a string containing the characters A, C, G and T. These letters
;    represent the four nucleobases adenine (A), cytosine (C), guanine (G), and thymine (T).
;    An example of a DNA string is "ATGCTTCAGAAAGGTCTTACG". Write a function sdsu-dna-count
;    that takes one argument, a DNA string, and returns a map that indicate the number of times
;    each of the four characters appears in the DNA string.

(defn sdsu-dna-count
  [s]
  (when (string? s)
    (into {}
       (for [[k v] (frequencies s)]
         [(keyword (str k)) v]))))


(= (sdsu-dna-count "ATGCTTC") {:A 1 :T 3 :G 1 :C 2})
(= (sdsu-dna-count "ATGCTTCAGAAAGGTCTTACG") {:A 6 :T 6 :G 5 :C 4})


; 6. Write a function, sdsu-digits, with two arguments, n and b. The first argument, n, is a non-
;    negative number in base 10. The second argument, b, is a positive integer also in based
;    ten. Sdsu-digits converts the first number from base 10 to base b. The return value is a collection
;    of the digits not as one number or as a single string. Digits should be represented
;    with their integer values. For 15 would be [1 5] in base 10, [1 1 1 1] in base 2 and [15] in
;    base 16.

(defn sdsu-digits
  [n b]
  (if (or (neg? n) (neg? b) (<= b 1))
    (throw (Exception. "IllegalArgumentException"))
    (if (zero? n)
      [0]
      (loop [n n
             b b
             output-list []]
        (if (zero? n)
          (into [] (reverse output-list))
          (recur (quot n b) b (conj output-list (mod n b))))))))


(= (sdsu-digits 12348012 10) [1 2 3 4 8 0 1 2])
(= (sdsu-digits 0 9) [0])
(= (sdsu-digits 140 8) [2 1 4])
(= (sdsu-digits 110 16) [6 14])



; 7. Write a function sdsu-roman-numeral has one argument, an integer smaller than 4000. The
;    function returns the corresponding roman numeral in uppercase. See
;    http://en.wikipedia.org/wiki/Roman_numerals for information about roman numerals.

(declare helper-roman-numeral)
(defn sdsu-roman-numeral
  [n]
  (if (or (> n 4000) (neg? n))
    (throw (Exception. "IllegalArgumentException"))
    (helper-roman-numeral n
                          nil)))

(defn- helper-roman-numeral
  [n output-list]
  (if (zero? n)
    (apply str (reverse output-list))
    (cond
       (>= n 1000)  (helper-roman-numeral (- n 1000) (conj output-list "M"))
       (>= n 900)   (helper-roman-numeral (- n 900) (conj output-list "CM"))
       (>= n 500)   (helper-roman-numeral (- n 500) (conj output-list "D"))
       (>= n 400)   (helper-roman-numeral (- n 400) (conj output-list "CD"))
       (>= n 100)   (helper-roman-numeral (- n 100) (conj output-list "C"))
       (>= n 90)    (helper-roman-numeral (- n 90) (conj output-list "XC"))
       (>= n 50)    (helper-roman-numeral (- n 50) (conj output-list "L"))
       (>= n 40)    (helper-roman-numeral (- n 40) (conj output-list "XL"))
       (>= n 10)    (helper-roman-numeral (- n 10) (conj output-list "X"))
       (>= n 9)     (helper-roman-numeral (- n 9) (conj output-list "IX"))
       (>= n 5)     (helper-roman-numeral (- n 5) (conj output-list "V"))
       (>= n 4)     (helper-roman-numeral (- n 4) (conj output-list "IV"))
       (>= n 1)     (helper-roman-numeral (- n 1) (conj output-list "I")))))


(= (sdsu-roman-numeral 1) "I")
(= (sdsu-roman-numeral 30) "XXX")
(= (sdsu-roman-numeral 4) "IV")
(= (sdsu-roman-numeral 9) "IX")
(= (sdsu-roman-numeral 40) "XL")
(= (sdsu-roman-numeral 90) "XC")
(= (sdsu-roman-numeral 400) "CD")
(= (sdsu-roman-numeral 900) "CM")
(= (sdsu-roman-numeral 1904) "MCMIV")















